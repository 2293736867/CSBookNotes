# 1 指令格式
一条指令必须显式或隐式给出如下信息：

- 操作码：指定操作类型
- 操作数或操作数的地址：指定一个或多个源操作数或他们的地址，可以是主存地址、寄存器编号或`I/O`端口，也可以是一个立即数
- 结果地址：存放操作结果的地址
- 下一条指令地址

根据指令显示给出的地址个数，可以将地址分为：

- 零地址指令
- 一地址指令
- 二地址指令
- 三地址指令

# 2 指令设计原则
- 指令尽量短
- 要有足够的操作码位数
- 操作码编码必须唯一解释
- 指令长度是字节的整数倍
- 指令应尽量规整


# 3 操作数类型
指令设计的操作数类型有如下几类：

- 指针或地址：指针或主存地址通常用无符号整数表示
- 数值数据：主要是带符号整数和浮点数
- 位、位串、字符、字符串
- 布尔数据

# 4 寻址方式
## 4.1 相关概念
- 有效地址：指令中给出的操作数所在的存储单元的地址
- 寻址方式：指令给出操作数或操作码的方式

## 4.2 立即寻址
立即寻址就是指令中给出操作数本身，这种操作数叫做立即数。

## 4.3 直接寻址
指令中给出的地址码是操作数的有效地址，这种地址叫做直接地址或绝对地址。
## 4.4 间接寻址
指令中给出的地址码是存放操作数有效地址的主存单元地址。
## 4.5 寄存器寻址
指令中给出的地址码是操作数所在的寄存器编号，操作数在寄存器中。

不需要访问内存。
## 4.6 寄存器间接寻址
指令中给出的地址码是一个寄存器编号，该寄存器中存放的是操作数的有效地址。

需要访问内存。
## 4.7 变址寻址
主要用于对数组之类的线性排列的元素进行访问，核心如下：

- 地址码字段给出一个基准地址
- 变址寄存器显式或隐式给出一个偏移量
- 线性集合中每个元素的有效地址为基准地址加上变址寄存器中的内容（也就是操作数的有效地址）
- 基准地址又叫形式地址
 
## 4.8 相对寻址
- 地址码字段给出一个偏移量，也叫形式地址
- 基准地址隐含由`PC`给出
- 操作数有效地址=转移目标地址=`PC`+偏移量

## 4.9 基址寻址
- 地址码字段给出一个偏移量，也叫形式地址
- 基准地址由基址寄存器显式或隐式给出
- 操作数有效地址为基准地址+形式地址

# 5 操作码编码
操作码的编码可以分两种：

- 定长
- 变长

希望降低空间开销时，可以使用变长编码，希望降低时间开销可以使用定长编码。

- 定长编码：采用固定长度编码，译码方便，指令执行速度快
- 扩展编码（变长编码）：将操作码编码分成几种固定长度的格式，操作码长度不固定，可变，这种编码方式被大多数非规整型指令集采用


# 6 `CISC`与`RISC`
## 6.1 `CISC`
复杂指令集计算机，特点：

- 指令系统复杂，指令多，寻址方式多，指令格式多
- 指令周期长
- 指令周期差距大
- 采用微程序控制
- 难以编译优化

## 6.2 `RISC`
精简指令集计算机，特点：

- 指令数目少
- 指令格式规整
- 采用`Load/Store`型指令设计风格
- 采用流水线方式执行指令
- 采用大量通用寄存器
- 采用硬连线控制器
- 采用优化的编译系统

# 7 `MIPS`汇编语言 
## 7.1 数据表示
提供了`32`个`32`位的通用寄存器，寄存器编号占`5`位，其中特殊的寄存器如下：

- `zero`：编号`0`，表示常数`0`
- `gp`/`sp`/`fp`：全局指针/栈指针/帧指针

`MIPS`中存储器按字节编址，采用大端方式存放数据，数据要求按字边界对齐，对于立即操作数，给出的如果是`16`位则需要扩充成`32`位才能参与运算。

## 7.2 指令格式
指令格式有三种：

- `R型指令`：操作码`OP`为`000000`，操作类型由`func`字段指定，寻址方式为寄存器寻址
- `I型指令`：立即数型指令，寻址方式有：寄存器寻址、立即数寻址、相对寻址、基址或变址寻址
- `J型指令`：无条件跳转指令，只有一种寻址方式：变通的直接寻址
## 7.3 汇编语言
一些简单的示例汇编如下：

- 加法：`add $1,$2,$3`，等价于`$1=$2+$3`
- 存储访问：`lw $1,100($2)`，等价于`$1=Memory[$2+100]`，`sw $1,100($2)`，等价于`Memory[$2+100]=$1`
- 逻辑运算：`and $1,$2,$3`，等价于`$1=$2 & $3`
- 条件：`beq $1,$2,L`，等价于`if($1==$2) go to L`，`slt $1,$2,$3`，等价于`if($2<$3) $1=1 else $1=0`
- 跳转：`j L`，等价于`go to L`，无条件跳转
