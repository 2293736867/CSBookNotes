1、C

2、D

3、B

4、D

5、B

用户不能通过指令直接指定标志寄存器编号来修改内容

6、C

`SS`型指令两个源操作数和目的操作数都在存储单元中，需要访问存储器的次数最多，执行时间最长

7、B

8、A

9、C

10、B

11、D

相对寻址就是`PC`+形式地址

12、A

变址寻址就是形式地址+变址值，变址值通过变址寄存器获取，也就是`R[X]`，因此`R[X]+D`就是有效地址，而`M[R[X]+D]`表示该有效地址在内存中的操作数的具体值

13、C

计算转移目标地址时，`CPU`已经取了两次值，一次是取操作码，一次是取相对位移量，也就是`PC`会变成`PC+2`，也就是`200EH`。

而转移目标地址=`PC`+位移量，位移量=`FFA2H`，取第二字节就是`A2H`。

14、C

变址寻址就是形式地址+变址值，也就是`B000H`+`124`=`B000H`+`007CH`=`B07CH`。

15、D

首先计算出最后一个数组元素的地址，`C000 1000H`+`4*99`=`C000 1000H`+`0000 018CH`=`C000 118CH`，由于按字节编址，需要进行扩展操作，因此实际保存的数据为：
```bash
C000 118CH
C000 118DH
C000 118EH
C000 118FH
```
由于是小端方式存储，因此`MSB`的值为`C000 118FH`（低字节保存低有效数据）。

16、B

一次间接寻址就是指令给出的地址码中的存储内容就是有效地址。

17、A

寄存器间接寻址方式中，操作数的有效地址在指令寄存器中给出

18、D

操作数的有效地址为形式地址+基址值，也就是`C000 0000H`+`FFFF FF00H`（补上`FFFF`是因为这是补码形式的形式地址，负数，而不是通常的加上`0000`）=`BFFF FF00H`，因为按字节编址，需要四个地址单元，也就是：

- `BFFF FF00H`
- `BFFF FF01H`
- `BFFF FF02H`
- `BFFF FF03H`

按照大端方式，就是`BFFF FF03H`。

19、D

操作数地址与上一题一样是`BFFF FF00H`，但是一个操作数为`16`位，占两个字节，因此需要两个地址单元，也就是：

- `BFFF FF00H`
- `BFFF FF01H`

结合小端编制方式可以确定`MSB`存放地址为`BFFF FF01H`。

20、C

21、D

寄存器指令完成通用寄存器与通用寄存器之间的数据传送。

22、C

23、C

24、D

调用指令执行时将无条件转移到目标地址处，这个目标地址就是被调用过程第一条指令的地址，一定在调用指令中明显给出。

25、C

在某些架构中，比如`IA-32`，可以通过`MOV`指令访问栈中的信息。



