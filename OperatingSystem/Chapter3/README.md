# Table of Contents

* [1 处理机与`CPU`](#1-处理机与cpu)
* [2 处理机调度](#2-处理机调度)
  * [2.1 调度层次](#21-调度层次)
  * [2.2 调度目标](#22-调度目标)
* [3 作业](#3-作业)
  * [3.1 作业和作业步](#31-作业和作业步)
  * [3.2 作业控制块](#32-作业控制块)
  * [3.3 三个阶段与三个状态](#33-三个阶段与三个状态)
* [4 作业调度](#4-作业调度)
  * [4.1 主要任务](#41-主要任务)
  * [4.2 常见算法](#42-常见算法)
    * [4.2.1 先来先服务调度算法](#421-先来先服务调度算法)
    * [4.2.2 短作业优先调度算法](#422-短作业优先调度算法)
    * [4.2.3 优先级调度算法](#423-优先级调度算法)
    * [4.2.4 高响应比优先级调度算法](#424-高响应比优先级调度算法)
* [5 进程调度](#5-进程调度)
  * [5.1 进程调度的任务](#51-进程调度的任务)
  * [5.2 进程调度需要的三部分](#52-进程调度需要的三部分)
  * [5.3 进程调度方式](#53-进程调度方式)
  * [5.4 轮转调度算法](#54-轮转调度算法)
  * [5.5 优先级调度算法](#55-优先级调度算法)
  * [5.6 多队列调度算法](#56-多队列调度算法)
  * [5.7 多级反馈队列调度算法](#57-多级反馈队列调度算法)
  * [5.8 基于公平原则的调度算法](#58-基于公平原则的调度算法)
* [6 实时调度](#6-实时调度)
  * [6.1 实时调度算法分类](#61-实时调度算法分类)
    * [6.1.1 非抢占式调度算法](#611-非抢占式调度算法)
    * [6.1.2 抢占式调度算法](#612-抢占式调度算法)
  * [6.2 最早截止时间优先算法](#62-最早截止时间优先算法)
  * [6.3 最低松弛度优先算法](#63-最低松弛度优先算法)
* [7 计算机中的资源](#7-计算机中的资源)
* [8 死锁](#8-死锁)
  * [8.1 定义](#81-定义)
  * [8.2 引发原因](#82-引发原因)
  * [8.3 死锁的必要条件](#83-死锁的必要条件)
  * [8.4 死锁处理方法](#84-死锁处理方法)
* [9 预防死锁](#9-预防死锁)
  * [9.1 破坏请求和保持条件](#91-破坏请求和保持条件)
    * [9.1.1 第一种协议](#911-第一种协议)
    * [9.1.2 第二种协议](#912-第二种协议)
  * [9.2 破坏不可抢占条件](#92-破坏不可抢占条件)
  * [9.3 破坏循环等待条件](#93-破坏循环等待条件)
* [10 避免死锁](#10-避免死锁)
  * [10.1 安全状态](#101-安全状态)
  * [10.2 银行家算法](#102-银行家算法)
    * [10.2.1 原理](#1021-原理)
    * [10.2.2 数据结构](#1022-数据结构)
    * [10.2.3 具体算法](#1023-具体算法)
* [11 检测死锁](#11-检测死锁)
  * [11.1 资源分配图](#111-资源分配图)
  * [11.2 死锁定理](#112-死锁定理)
* [12 解除死锁](#12-解除死锁)


﻿
# 1 处理机与`CPU`
处理机包括`CPU`、主存、`I/O`接口，加上外围设备就可以构成完整的计算机系统，而`CPU`是一台计算机运算核心，功能是解释计算机指令以及处理计算机软件中的数据。

# 2 处理机调度

## 2.1 调度层次
三个：

- **高级调度：调度对象是作业，主要用于多道批处理系统中**
- **低级调度：调度对象是进程（或内核级线程），主要是根据某种算法确认就绪队列中的哪个进程获得处理机**
- **中级调度：又叫内存调度，把暂时不能运行的进程调至外存等待**


## 2.2 调度目标
- 提供资源利用率：资源利用率可用以下公式计算：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201013194943556.png)

- 提高公平性以及平衡性：公平性指进程获得合理的`CPU`时间，不会发生进程饥饿，而平衡性是指需要保持系统资源使用的平衡性
- 策略强制执行：只要需要必须予以准确执行策略


# 3 作业
## 3.1 作业和作业步
- 作业：用户提交给系统的一项相对独立的工作，不仅包含程序和数据，还有一份作业说明书。在批处理系统中一作业为基本单位从外存调入
- 作业步：作业的一个步骤叫作业步，比如一个典型的作业可以分为编译作业步，链接装配作业步和运行作业步

## 3.2 作业控制块
操作系统为每个作业设置了一个作业控制块`JCB`，是作业在系统中存在的标志，通常包含的内容有：

- 作业标识
- 用户名称
- 用户账号
- 作业类型
- 作业状态
- 调度信息
- 资源需求
- 资源使用情况

## 3.3 三个阶段与三个状态
作业运行需要经理三个状态：

- **后备状态**
- **运行状态**
- **完成状态**

需要经历的三个阶段为：

- 收容阶段：操作员把作业输入到硬盘上，为该作业建立`JCB`，并放入后备队列，此时为后备状态
- 运行阶段：分配必要的资源和建立进程运行，处于运行状态
- 完成阶段：运行完成或异常终止便进行完成阶段，处于完成状态


# 4 作业调度
## 4.1 主要任务
作业调度的主要任务是根据`JCB`中的信息从后备队列中选择某些作业调入内存，并创建进程和分配必要的资源，每次调度需要做出以下两个决定：

- 接纳多少个作业：太少的话不能充分利用处理器，太多的话会导致中断增加，使得平均周转时间变长，需要合理选择作业数量
- 接纳哪些作业：根据调度算法选择将哪些作业调入内存

## 4.2 常见算法
### 4.2.1 先来先服务调度算法
又叫`FCFS`算法，系统按照作业到达的先后次序进行调度，换句话说，是**优先考虑等待时间最长的作业**，**不考虑执行时间**。
### 4.2.2 短作业优先调度算法
又叫`SJF`算法，**以作业长短来计算优先级，作业越短优先级越高，作业长短以运行时间衡量**。相比起`FCFS`：

- 必须预知作业运行时间
- 对长作业不利
- 无法实现人机交互
- 未考虑作业紧迫程度


### 4.2.3 优先级调度算法
基于作业紧迫程度，以该指标计算优先级进行调度，可以保证紧迫性作业优先运行。

### 4.2.4 高响应比优先级调度算法
高响应比优先级调度算法实质上是以上三者的综合，既考虑了作业的等待时间，也考虑了作业的运行时间，为每个作业引入一个动态优先级：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201013200935371.png)

特点：

- 若等待时间相同，要求服务时间越短优先级越高，类似`SJF`
- 若要求服务时间相同，等待时间越长优先级越高，类似`FCFS`
- 对于长作业的优先级，会随等待时间等待时间的增加而提高，等待时间足够长可以获得处理机
- 每次调度前需要进行响应比计算，增加系统开销

# 5 进程调度
## 5.1 进程调度的任务
三个：

- 保存处理机的现场信息
- 按某种算法选取进程
- 把处理器分配给进程

## 5.2 进程调度需要的三部分
- 排队器：将所有就绪进程按照一定策略排成一个队列
- 分派器：根据进程调度程序选定的进程，从就绪队列中取出并进行上下文切换
- 上下文切换器：分为两对上下文切换，第一对是`OS`保存当前进程的上下文并装入分派程序的上下文，第二对是一出分派程序的上下文并装入新进程的上下文

## 5.3 进程调度方式
- 非抢占式方式：进程会一直占据处理机直到进程完成或阻塞，这种方式适用于大多数批处理系统
- 抢占式方式：暂停某个执行中的进程并将处理机分配给新进程，也就是新进程“抢占”了原进程的处理机
- 三大原则：抢占式需要遵循的原则是**优先权原则、短进程优先原则、时间片原则**

## 5.4 轮转调度算法
- 分时系统中最常用最简单的算法，也叫`RR`（`round robin`）算法
- **公平处理方式，就绪队列上的每个进程仅运行一个时间片**
- 原理：根据`FCFS`将所有进程排成就绪队列，设置一定时间间隔产生中断，时间片耗尽或运行完毕时，将`CPU`分配给新队首进程
- 时间片大小：一般设置为略大于一次典型交互需要的时间

## 5.5 优先级调度算法
可以分为：

- 非抢占式优先级调度算法：采用非抢占式调度方式+优先级的调度算法
- 抢占式优先级调度算法：采用抢占式调度方式+优先级的调度算法

优先级的类型可以分为：

- 静态优先级：通常为一个运行时固定的整数，一般根据进程类型、进程对资源的需求以及用户要求确定
- 动态优先级：创建时赋予优先级一个初始值，而后根据实际情况使其动态变化

## 5.6 多队列调度算法
- 就绪队列从一个拆分为若干个
- 不同类型或性质的进程固定分配在不同的就绪队列
- 不同的就绪队列采用不同的调度算法
 
## 5.7 多级反馈队列调度算法
三个核心：

- 在多队列调度算法的基础上，为不同队列设置不同的优先级，同时不同队列具有不同时间片大小，关系是，优先级越高的队列时间片越小
- 每个队列采用`FCFS`，进程在一个时间片内未完成则放入下一队列队尾
- 按队列优先级调度

## 5.8 基于公平原则的调度算法

- 保证调度算法：明确性能保证，能保证调度公平，保证每个进程获得相同的处理机时间
- 公平分享调度算法：针对用户而言，使所有用户获得相同的处理机时间


# 6 实时调度
## 6.1 实时调度算法分类
可以分为非抢占式调度以及抢占式调度。
### 6.1.1 非抢占式调度算法
可以分为：

- 非抢占式轮转调度算法：每个进程获得相同处理机时间且进程独占的调度算法
- 非抢占式优先调度算法：进程独占的加上优先级调度的调度算法

### 6.1.2 抢占式调度算法
可以分为：

- 基于时钟中断的抢占式优先级调度算法：等到时钟中断发生后旧进程让出处理机
- 立即抢占的优先级调度算法：出现外部中断时，只要旧进程未占有临界资源，立即让出处理机

## 6.2 最早截止时间优先算法
根据任务截止时间确定任务优先级，截止时间越早优先级越高。可以同时用于抢占式调度以及非抢占式调度。

## 6.3 最低松弛度优先算法
根据任务的紧急程度确定优先级，越紧急优先级越高，主要用于可抢占式调度中。

# 7 计算机中的资源
计算机中的资源可以分为：

- 可重用性资源：可重用，使用前需要申请，使用后释放
- 可消耗性资源：动态创建和消耗
- 可抢占性资源：获得了该资源后可以被其他进程抢占
- 不可抢占性资源：进程占有后只能由进程本身自行释放

# 8 死锁
## 8.1 定义
**进程中每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。**

## 8.2 引发原因
- 竞争不可抢占性资源
- 竞争可消耗性资源
- 进程推进顺序不当

## 8.3 死锁的必要条件
- **互斥条件**：进程对分配到的资源排它性使用，在一段时间内只能由一个进程独占
- **请求和保持条件**：进程已获得资源，申请资源时由于新资源被其他进程占有，因此处于阻塞状态，但是并没有释放本身已占有的资源
- **不可抢占条件**：进程获得的不可抢占资源只能有进程本身释放
- **循环等待条件**：一组进程之间，前一个进程申请下一个进程占有的资源，一直到末尾最后一个进程申请第一个进程占有的资源，形成了一条占用链

## 8.4 死锁处理方法
- 预防死锁
- 避免死锁
- 检测死锁
- 解除死锁

# 9 预防死锁
## 9.1 破坏请求和保持条件
### 9.1.1 第一种协议
进程开始运行之前一次性申请整个运行时间所需的资源，类似`AND`型信号量。

优点：

- 简单
- 安全
- 易操作

缺点：

- 资源严重浪费
- 进程饥饿经常发生

### 9.1.2 第二种协议
- 对第一种协议的改进，允许进程只获得运行初期所需的资源
- 运行过程中动态释放不需要的资源以及动态申请新资源
- 优点是提高设备利用率，减少进程饥饿的发生几率

## 9.2 破坏不可抢占条件
实现复杂，代价大，因为比如打印机之类的不可抢占资源，抢占后可能导致前一阶段工作失效。

## 9.3 破坏循环等待条件
- 规定进程需要按序号递增的顺序申请资源
- 优点：利用率和吞吐量明显改善
- 缺点：资源号的规定必须相对稳定，资源容易浪费，编程实现难度较高

# 10 避免死锁
## 10.1 安全状态
在该方法（避免死锁）中，把系统状态分为：

- 安全状态：不会发生死锁的状态
- 非安全状态：会发生死锁的状态

## 10.2 银行家算法
避免死锁可以利用银行家算法来检测系统分配资源后是否处于不安全状态。

### 10.2.1 原理
- 进程申请一组资源时，系统首先判断是否有足够资源分配给该进程
- 若有足够资源，再利用算法来判断系统是否处于不安全状态
- 如果不会，则分配资源

### 10.2.2 数据结构
假设有`n`个进程以及`m`个资源

- 可用资源数`Available`：一维数组，`m`个元素，每一个元素代表第`m`个资源目前可用的资源数
- 最大需要资源数`Max`：二维数组，`n*m`，每一行表示一个进程所需的资源，每个具体元素表示第`n`个进程需要的第`m`个资源的最大数目
- 已分配资源数`Allocation`：二维数组，`n*m`，每一行代表已经分配给一个进程的资源数，每个具体元素表示第`n`个进程已分配的第`m`个资源的资源数
- 目前需要资源数`Need`：二维数组，`n*m`，每一行表示一个进程目前需要的资源数，每个具体元素表示第`n`个进程需要的第`m`个资源的数目

### 10.2.3 具体算法
- 确定申请资源二维数组`R[i,j]`，表示第`i`个进程申请第`j`个资源的数量
- 如果`R[i,j]<=Need[i,j]`，下一步操作，否则报错，因为需要的资源已超过申请的最大值
- 如果`R[i,j]<=Avaliable[j]`，进行下一步操作，否则认为无足够资源
- 尝试分配资源，进行如下操作：`Avaliable[i,j]=Avaliable[i,j]-R[i,j]`，`Need[i,j]=Need[i,j]-R[i,j]`，`Allocation[i,j]=Allocation[i,j]+R[i,j]`
- 进行安全性检测

其中安全性检测的关键是为每个进程设置一个布尔变量`Finish[i]`，若为`true`表示进程能够申请到资源，若为`false`表示不能申请到资源，同时设置一个会累加的二维数组`Work[j]`，并初始化为`Avaliable`，具体步骤：

- 初始化：`Finish[i]=false`，`Work[j]=Avaliable[j]`
- 寻找进程：找到一个`Finish[i]=false`且`Need[i,j]<=Work[i,j]`的进程
- 分配资源：将上一步找到的进程进行资源分配，`Work[j]=Work[j]+Allocation[i,j]`，`Finish[i]=true`
- 判断：循环上述步骤如果所有的`Finish[i]`都为`true`则处于安全状态

# 11 检测死锁
检测死锁一般利用一个叫资源分配图的有向图进行检测。
## 11.1 资源分配图
- 一个有向图
- 节点分为资源节点以及进程节点
- 资源节点指向进程节点的边叫资源分配边，进程节点指向资源节点的边叫资源申请边
- 圆圈代表进程节点，矩形代表资源节点

如图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201027104033465.png)

## 11.2 死锁定理
如果资源分配图能够简化，则不会发生死锁。

简化指的是从某个进程开始，获取资源并运行完毕释放进程，并删除与该进程有关的资源请求边以及资源分配边，直到遍历所有的进程，如果最后能使所有进程都成为孤立点，则称为可简化的。

# 12 解除死锁
常用的两种方法如下：

- 终止所有死锁进程：死锁肯定会解除，但代价很大
- 逐个终止死锁进程：逐个终止进程，直到把死锁解除，但是也需要付出较大代价，因为每终止一个进程都需要检测一遍死锁，而且存在终止进程的选择问题




